generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/// This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
model conversations {
  conversation_id                  String              @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user1                            String?             @db.Uuid
  user2                            String?             @db.Uuid
  created_at                       DateTime?           @default(now()) @db.Timestamptz(6)
  conversation_status              conversation_status @default(active)
  conversation_updated_at          DateTime?           @default(now()) @db.Timestamptz(6)
  users_conversations_user2Tousers users?              @relation("conversations_user2Tousers", fields: [user2], references: [user_id], onDelete: Cascade, onUpdate: NoAction, map: "conversations_receiver_id_fkey")
  users_conversations_user1Tousers users?              @relation("conversations_user1Tousers", fields: [user1], references: [user_id], onDelete: Cascade, onUpdate: NoAction, map: "conversations_sender_id_fkey")
  messages                         messages[]

  @@unique([user1, user2], map: "conversations_sender_id_receiver_id_key")
  @@index([user2], map: "idx_conversations_receiver")
  @@index([user1], map: "idx_conversations_sender")
}

model messages {
  msg_id                            String         @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  msg                               String
  sent_at                           DateTime?      @default(now()) @db.Timestamptz(6)
  status                            message_status @default(sent)
  conversation_id                   String?        @db.Uuid
  msg_updated_at                    DateTime?      @default(now()) @db.Timestamptz(6)
  receiver_id                       String?        @db.Uuid
  sender_id                         String?        @db.Uuid
  conversations                     conversations? @relation(fields: [conversation_id], references: [conversation_id], onDelete: NoAction, onUpdate: NoAction, map: "fk_messages_conversation")
  users_messages_receiver_idTousers users?         @relation("messages_receiver_idTousers", fields: [receiver_id], references: [user_id], onDelete: NoAction, onUpdate: NoAction, map: "fk_messages_receiver")
  users_messages_sender_idTousers   users?         @relation("messages_sender_idTousers", fields: [sender_id], references: [user_id], onDelete: NoAction, onUpdate: NoAction, map: "fk_messages_sender")

  @@index([conversation_id], map: "idx_messages_conversation")
}

model users {
  user_id                                  String          @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  username                                 String          @unique @db.VarChar(50)
  created_at                               DateTime?       @default(now()) @db.Timestamptz(6)
  first_name                               String          @db.VarChar(50)
  last_name                                String          @db.VarChar(50)
  hashed_password                          String          @db.Char(60)
  conversations_conversations_user2Tousers conversations[] @relation("conversations_user2Tousers")
  conversations_conversations_user1Tousers conversations[] @relation("conversations_user1Tousers")
  messages_messages_receiver_idTousers     messages[]      @relation("messages_receiver_idTousers")
  messages_messages_sender_idTousers       messages[]      @relation("messages_sender_idTousers")
}

enum conversation_status {
  active
  archived
}

enum message_status {
  sent
  delivered
  read
  failed
}
